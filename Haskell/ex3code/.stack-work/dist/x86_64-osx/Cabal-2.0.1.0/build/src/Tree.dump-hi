
==================== FINAL INTERFACE ====================
2018-11-21 09:33:32.373392 UTC

interface ex3code-0.1.0.0-6rUj3bfK7Y5I8oTjgnWRc3:Tree 8022
  interface hash: 3c9bacfbffa02bf405fc58f29692efe4
  ABI hash: d1cba58ceff1ba9dd2ff18298c912d4f
  export-list hash: d92ac094257c6b3a4521e5d691789b27
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 0451a77cc0d8e5d99d548d6441c7dd35
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tree.Tree{Tree.Branch Tree.Leaf}
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Err 514b3a24b22e9d7d731c2d0d02d10842
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
c40e7b79123ffcae53950d7b744f8c27
  $fEqTree :: GHC.Classes.Eq a => GHC.Classes.Eq (Tree.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Tree.Tree a)
                  (Tree.$fEqTree_$c== @ a v)
                  (Tree.$fEqTree_$c/= @ a v) -}
c40e7b79123ffcae53950d7b744f8c27
  $fEqTree_$c/= ::
    GHC.Classes.Eq a => Tree.Tree a -> Tree.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Tree.Tree a)
                   (b :: Tree.Tree a) ->
                 case Tree.$fEqTree_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c40e7b79123ffcae53950d7b744f8c27
  $fEqTree_$c== ::
    GHC.Classes.Eq a => Tree.Tree a -> Tree.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree :: Data.Foldable.Foldable Tree.Tree
  DFunId
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Tree.Tree
                  Tree.$fFoldableTree_$cfold
                  Tree.$fFoldableTree_$cfoldMap
                  Tree.$fFoldableTree_$cfoldr
                  Tree.$fFoldableTree_$cfoldr'
                  Tree.$fFoldableTree_$cfoldl
                  Tree.$fFoldableTree_$cfoldl'
                  Tree.$fFoldableTree_$cfoldr1
                  Tree.$fFoldableTree_$cfoldl1
                  Tree.$fFoldableTree_$ctoList
                  (\ @ a ->
                   case Tree.$fFoldableTree9
                   ret_ty (Tree.Tree a -> GHC.Types.Bool)
                   of {})
                  Tree.$fFoldableTree_$clength
                  Tree.$fFoldableTree_$celem
                  Tree.$fFoldableTree_$cmaximum
                  Tree.$fFoldableTree_$cminimum
                  Tree.$fFoldableTree3
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Tree.Tree a>_R
                   ->_R Data.Monoid.N:Sum[0] <a>_R)
                  Tree.$fFoldableTree1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Tree.Tree a>_R
                   ->_R Data.Monoid.N:Product[0] <a>_R) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree1 ::
    GHC.Num.Num a => Tree.Tree a -> Data.Monoid.Product a
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 case Tree.$fFoldableTree2
                 ret_ty (Tree.Tree a -> Data.Monoid.Product a)
                 of {}) -}
07ed6f107d46901df8053763f3523526
  $fFoldableTree10 :: GHC.Stack.Types.CallStack
  {- Strictness: m2,
     Unfolding: (GHC.Stack.Types.PushCallStack
                   Tree.$fFoldableTree21
                   Tree.$fFoldableTree11
                   GHC.Stack.Types.EmptyCallStack) -}
44d437ac8853279272b00397c43b3b5f
  $fFoldableTree11 :: GHC.Stack.Types.SrcLoc
  {- Strictness: m,
     Unfolding: (GHC.Stack.Types.SrcLoc
                   Tree.$fFoldableTree19
                   Tree.$fFoldableTree17
                   Tree.$fFoldableTree15
                   Tree.$fFoldableTree14
                   Tree.$fFoldableTree13
                   Tree.$fFoldableTree14
                   Tree.$fFoldableTree12) -}
d6690694d25fa68720fc1dcc4aabef0c
  $fFoldableTree12 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 22#) -}
312e3d9a6ae3d3da8211ef218b765d65
  $fFoldableTree13 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 13#) -}
151627b9d91e5b1476b645c4e5881e27
  $fFoldableTree14 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 24#) -}
f02ba178eabaf8698cfed07922db1d49
  $fFoldableTree15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Tree.$fFoldableTree16) -}
95f135c3af802e01fbee91f35f099219
  $fFoldableTree16 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/Tree.hs"#) -}
75a157ff43c8558a6915ecd226033821
  $fFoldableTree17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Tree.$fFoldableTree18) -}
f9e67fec81a65d833601f45e1e67d8c1
  $fFoldableTree18 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
6a7da87d311f3bc87932060fec5c6f2f
  $fFoldableTree19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Tree.$fFoldableTree20) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree2 ::
    (a -> Data.Monoid.Product a -> Data.Monoid.Product a)
    -> Data.Monoid.Product a -> Tree.Tree a -> Data.Monoid.Product a
  {- Strictness: x -}
33a118a86832923807dfe976da390752
  $fFoldableTree20 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("ex3code-0.1.0.0-6rUj3bfK7Y5I8oTjgnWRc3"#) -}
5aff6cd6ba65e0746215c2275d53c48f
  $fFoldableTree21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Tree.$fFoldableTree22) -}
9146739374dce37441888bed6b078031
  $fFoldableTree22 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("undefined"#) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree23 ::
    (a
     -> Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a))
     -> Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a)))
    -> Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a))
    -> Tree.Tree a
    -> Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a))
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree24 ::
    (a -> GHC.Base.Maybe a -> GHC.Base.Maybe a)
    -> GHC.Base.Maybe a -> Tree.Tree a -> GHC.Base.Maybe a
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree25 ::
    (a -> (b -> b) -> b -> b) -> (b -> b) -> Tree.Tree a -> b -> b
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree26 ::
    (a
     -> Data.Monoid.Dual (Data.Monoid.Endo b)
     -> Data.Monoid.Dual (Data.Monoid.Endo b))
    -> Data.Monoid.Dual (Data.Monoid.Endo b)
    -> Tree.Tree a
    -> Data.Monoid.Dual (Data.Monoid.Endo b)
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree27 ::
    (a
     -> Data.Monoid.Dual (Data.Monoid.Endo (b -> b))
     -> Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))
    -> Data.Monoid.Dual (Data.Monoid.Endo (b -> b))
    -> Tree.Tree a
    -> Data.Monoid.Dual (Data.Monoid.Endo (b -> b))
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree28 :: (m -> m -> m) -> m -> Tree.Tree m -> m
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree3 ::
    GHC.Num.Num a => Tree.Tree a -> Data.Monoid.Sum a
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 case Tree.$fFoldableTree4
                 ret_ty (Tree.Tree a -> Data.Monoid.Sum a)
                 of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree4 ::
    (a -> Data.Monoid.Sum a -> Data.Monoid.Sum a)
    -> Data.Monoid.Sum a -> Tree.Tree a -> Data.Monoid.Sum a
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree5 ::
    (a -> Data.Functor.Utils.Min a -> Data.Functor.Utils.Min a)
    -> Data.Functor.Utils.Min a
    -> Tree.Tree a
    -> Data.Functor.Utils.Min a
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree6 ::
    (a -> Data.Functor.Utils.Max a -> Data.Functor.Utils.Max a)
    -> Data.Functor.Utils.Max a
    -> Tree.Tree a
    -> Data.Functor.Utils.Max a
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree7 ::
    (a -> Data.Monoid.Any -> Data.Monoid.Any)
    -> Data.Monoid.Any -> Tree.Tree a -> Data.Monoid.Any
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree8 ::
    (a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int)
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> Tree.Tree a
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree9 ::
    (a -> GHC.Types.Bool -> GHC.Types.Bool)
    -> GHC.Types.Bool -> Tree.Tree a -> GHC.Types.Bool
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$celem ::
    GHC.Classes.Eq a => a -> Tree.Tree a -> GHC.Types.Bool
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 case Tree.$fFoldableTree7
                 ret_ty (Tree.Tree a -> GHC.Types.Bool)
                 of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfold :: GHC.Base.Monoid m => Tree.Tree m -> m
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, False)
                (\ @ m ($dMonoid :: GHC.Base.Monoid m) ->
                 case Tree.$fFoldableTree28 ret_ty (Tree.Tree m -> m) of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> Tree.Tree a -> m
  {- Arity: 2, Strictness: <B,A><B,A>b, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ m @ a ($dMonoid :: GHC.Base.Monoid m) (f2 :: a -> m) ->
                 case GHC.Err.undefined
                        @ 'GHC.Types.LiftedRep
                        @ ((a -> m -> m) -> m -> Tree.Tree a -> m)
                        Tree.$fFoldableTree10
                          `cast`
                        (Sym (GHC.Classes.N:IP[0]
                                  <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                 ret_ty (Tree.Tree a -> m)
                 of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfoldl :: (b -> a -> b) -> b -> Tree.Tree a -> b
  {- Arity: 3, Strictness: <B,A><B,A><B,A>b,
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a (f2 :: b -> a -> b) (z :: b) (t1 :: Tree.Tree a) ->
                 case Tree.$fFoldableTree26 ret_ty b of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfoldl' :: (b -> a -> b) -> b -> Tree.Tree a -> b
  {- Arity: 3, Strictness: <B,A><B,A><B,A>b,
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a (f2 :: b -> a -> b) (z0 :: b) (xs :: Tree.Tree a) ->
                 case Tree.$fFoldableTree25 ret_ty b of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfoldl1 :: (a -> a -> a) -> Tree.Tree a -> a
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (f2 :: a -> a -> a) (xs :: Tree.Tree a) ->
                 case Tree.$fFoldableTree23 ret_ty a of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfoldr :: (a -> b -> b) -> b -> Tree.Tree a -> b
  {- Strictness: x -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfoldr' :: (a -> b -> b) -> b -> Tree.Tree a -> b
  {- Arity: 3, Strictness: <B,A><B,A><B,A>b,
     Unfolding: InlineRule (3, True, False)
                (\ @ a @ b (f2 :: a -> b -> b) (z0 :: b) (xs :: Tree.Tree a) ->
                 case Tree.$fFoldableTree27 ret_ty b of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cfoldr1 :: (a -> a -> a) -> Tree.Tree a -> a
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (f2 :: a -> a -> a) (xs :: Tree.Tree a) ->
                 case Tree.$fFoldableTree24 ret_ty a of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$clength :: Tree.Tree a -> GHC.Types.Int
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: Tree.Tree a) ->
                 case Tree.$fFoldableTree8 ret_ty GHC.Types.Int of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cmaximum :: GHC.Classes.Ord a => Tree.Tree a -> a
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) (eta :: Tree.Tree a) ->
                 case Tree.$fFoldableTree6 ret_ty a of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$cminimum :: GHC.Classes.Ord a => Tree.Tree a -> a
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) (eta :: Tree.Tree a) ->
                 case Tree.$fFoldableTree5 ret_ty a of {}) -}
c40e7b79123ffcae53950d7b744f8c27
  $fFoldableTree_$ctoList :: Tree.Tree a -> [a]
  {- Arity: 1, Strictness: <B,A>b, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Tree.Tree a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    case GHC.Err.undefined
                           @ 'GHC.Types.LiftedRep
                           @ ((a -> b -> b) -> b -> Tree.Tree a -> b)
                           Tree.$fFoldableTree10
                             `cast`
                           (Sym (GHC.Classes.N:IP[0]
                                     <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                    ret_ty b
                    of {})) -}
c40e7b79123ffcae53950d7b744f8c27
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (Tree.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Tree.Tree a)
                  (Tree.$fShowTree_$cshowsPrec @ a v)
                  (Tree.$fShowTree_$cshow @ a v)
                  (Tree.$fShowTree_$cshowList @ a v) -}
fe25bbf16903c35ab2e0657482508e1d
  $fShowTree1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
c40e7b79123ffcae53950d7b744f8c27
  $fShowTree_$cshow ::
    GHC.Show.Show a => Tree.Tree a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Tree.Tree a) ->
                 Tree.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   Tree.$fShowTree1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c40e7b79123ffcae53950d7b744f8c27
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [Tree.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Tree.Tree a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Tree.Tree a)
                   (Tree.$fShowTree_$cshowsPrec @ a $dShow Tree.$fShowTree1)
                   eta
                   eta1) -}
c40e7b79123ffcae53950d7b744f8c27
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Tree.Tree a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Tree.Tree a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tree.$w$cshowsPrec @ a w ww1 w2 }) -}
6fd4b2010842797d43d3e777223254e3
  $tc'Branch :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1062683623886900331##
                   14601858965021847909##
                   Tree.$trModule
                   Tree.$tc'Branch2
                   1#
                   Tree.$tc'Branch1) -}
81e781219e74584d4109175669a5159c
  $tc'Branch1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
699e1e097528929deac95777ba644c1a
  $tc'Branch2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Tree.$tc'Branch3) -}
e6ca2a06536d4d445aba82ef3660f786
  $tc'Branch3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Branch"#) -}
6f3ef78825a1a3d1a6dc3ef0a147bf99
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4797420067650423206##
                   7371070675600275777##
                   Tree.$trModule
                   Tree.$tc'Leaf2
                   1#
                   Tree.$tc'Leaf1) -}
d8c38850eaabd738f1ab3d462dcc5845
  $tc'Leaf1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4af91ee0366752521e91adabafa06203
  $tc'Leaf2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Tree.$tc'Leaf3) -}
7df4ef9077b701d4d42bfcddbdf16d62
  $tc'Leaf3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leaf"#) -}
abd4019ffacbb907751d01f51c940328
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   413571253305286756##
                   13531043519877331261##
                   Tree.$trModule
                   Tree.$trModule1
                   0#
                   GHC.Types.krep$*Arr*) -}
c3c3320e82293cc8d5d38cb64d18048a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Tree.$trModule2 Tree.$trModule1) -}
29c43dad6d89e14e73cf422caef5160d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Tree.$fFoldableTree18) -}
250d144f4bc05dfc86aeddb84d9864d6
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Tree.$fFoldableTree20) -}
c40e7b79123ffcae53950d7b744f8c27
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> Tree.Tree a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0] -}
c40e7b79123ffcae53950d7b744f8c27
  data Tree a = Branch (Tree.Tree a) a (Tree.Tree a) | Leaf a
instance [safe] GHC.Classes.Eq [Tree.Tree] = Tree.$fEqTree
instance [safe] Data.Foldable.Foldable [Tree.Tree]
  = Tree.$fFoldableTree
instance [safe] GHC.Show.Show [Tree.Tree] = Tree.$fShowTree
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

